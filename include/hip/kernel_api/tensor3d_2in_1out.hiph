/*
    Copyright (c) 2025 Alessandro Baretta <alex@baretta.com>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.
*/


// source path: include/hip/kernel_api/tensor3d_2in_1out.hiph

#pragma once

#include <hip/hip_runtime.h>
#include <Eigen/Dense>

#include "common/types/tensor3d.hpp"
#include "type_traits.hiph"

template <typename Tensor3D_kernel_spec_2In_1Out>
concept TENSOR3D_KERNEL_SPEC_2IN_1OUT = requires (Tensor3D_kernel_spec_2In_1Out spec) {
    { spec.n_rows_A_ } -> std::same_as<const long&>;
    { spec.n_cols_A_ } -> std::same_as<const long&>;
    { spec.n_sheets_A_ } -> std::same_as<const long&>;

    { spec.n_rows_B_ } -> std::same_as<const long&>;
    { spec.n_cols_B_ } -> std::same_as<const long&>;
    { spec.n_sheets_B_ } -> std::same_as<const long&>;

    { spec.n_rows_C_ } -> std::same_as<const long&>;
    { spec.n_cols_C_ } -> std::same_as<const long&>;
    { spec.n_sheets_C_ } -> std::same_as<const long&>;

    { spec.n_rows_temp_ } -> std::same_as<const long&>;
    { spec.n_cols_temp_ } -> std::same_as<const long&>;
    { spec.n_sheets_temp_ } -> std::same_as<const long&>;

    { dim3(spec.block_dim_) } -> std::same_as<dim3>;
    { dim3(spec.grid_dim_) } -> std::same_as<dim3>;
};

template <typename Tensor3D_kernel_spec_2In_1Out>
struct Check_tensor3d_kernel_spec_2In_1Out {
    static_assert(std::same_as<decltype(std::declval<Tensor3D_kernel_spec_2In_1Out>().n_rows_A_), const long>);
    static_assert(std::same_as<decltype(std::declval<Tensor3D_kernel_spec_2In_1Out>().n_cols_A_), const long>);
    static_assert(std::same_as<decltype(std::declval<Tensor3D_kernel_spec_2In_1Out>().n_sheets_A_), const long>);

    static_assert(std::same_as<decltype(std::declval<Tensor3D_kernel_spec_2In_1Out>().n_rows_B_), const long>);
    static_assert(std::same_as<decltype(std::declval<Tensor3D_kernel_spec_2In_1Out>().n_cols_B_), const long>);
    static_assert(std::same_as<decltype(std::declval<Tensor3D_kernel_spec_2In_1Out>().n_sheets_B_), const long>);

    static_assert(std::same_as<decltype(std::declval<Tensor3D_kernel_spec_2In_1Out>().n_rows_C_), const long>);
    static_assert(std::same_as<decltype(std::declval<Tensor3D_kernel_spec_2In_1Out>().n_cols_C_), const long>);
    static_assert(std::same_as<decltype(std::declval<Tensor3D_kernel_spec_2In_1Out>().n_sheets_C_), const long>);

    static_assert(std::same_as<decltype(std::declval<Tensor3D_kernel_spec_2In_1Out>().n_rows_temp_), const long>);
    static_assert(std::same_as<decltype(std::declval<Tensor3D_kernel_spec_2In_1Out>().n_cols_temp_), const long>);
    static_assert(std::same_as<decltype(std::declval<Tensor3D_kernel_spec_2In_1Out>().n_sheets_temp_), const long>);

    static_assert(std::same_as<decltype(std::declval<Tensor3D_kernel_spec_2In_1Out>().block_dim_), const dim3>);
    static_assert(std::same_as<decltype(std::declval<Tensor3D_kernel_spec_2In_1Out>().grid_dim_), const dim3>);

    static_assert(TENSOR3D_KERNEL_SPEC_2IN_1OUT<Tensor3D_kernel_spec_2In_1Out>, "not a valid TENSOR3D_KERNEL_SPEC_2IN_1OUT");

    constexpr static bool check_passed = true;
};

template <typename Tensor3D_kernel_2In_1Out>
concept TENSOR3D_KERNEL_2IN_1OUT = requires (Tensor3D_kernel_2In_1Out kernel) {
    typename Tensor3D_kernel_2In_1Out::Number;
    typename Tensor3D_kernel_2In_1Out::Kernel_spec;

    { kernel.spec_ } -> std::same_as<const typename Tensor3D_kernel_2In_1Out::Kernel_spec&>;
    { kernel.run_device_kernel(
        std::declval<const typename Tensor3D_kernel_2In_1Out::Number*>(),
        std::declval<const typename Tensor3D_kernel_2In_1Out::Number*>(),
        std::declval<typename Tensor3D_kernel_2In_1Out::Number*>(),
        std::declval<typename Tensor3D_kernel_2In_1Out::Number*>(),
        std::declval<hipStream_t>()
    ) } -> std::same_as<void>;
    { kernel.run_host_kernel(
        std::declval<const Tensor3D<typename Tensor3D_kernel_2In_1Out::Number>&>(),
        std::declval<const Tensor3D<typename Tensor3D_kernel_2In_1Out::Number>&>()
    ) } -> std::same_as<Tensor3D<typename Tensor3D_kernel_2In_1Out::Number>>;
};

template <typename Tensor3D_kernel_2In_1Out>
struct Check_tensor3d_kernel_2In_1Out {
    using Number = typename Tensor3D_kernel_2In_1Out::Number;
    using Kernel_spec = typename Tensor3D_kernel_2In_1Out::Kernel_spec;

    static_assert(std::same_as<decltype(std::declval<Tensor3D_kernel_2In_1Out>().spec_), const typename Tensor3D_kernel_2In_1Out::Kernel_spec>);
    static_assert(std::same_as<decltype(std::declval<Tensor3D_kernel_2In_1Out>().run_device_kernel(
        std::declval<const typename Tensor3D_kernel_2In_1Out::Number*>(),
        std::declval<const typename Tensor3D_kernel_2In_1Out::Number*>(),
        std::declval<typename Tensor3D_kernel_2In_1Out::Number*>(),
        std::declval<typename Tensor3D_kernel_2In_1Out::Number*>(),
        std::declval<hipStream_t>()
    )), void>);
    static_assert(std::same_as<decltype(std::declval<Tensor3D_kernel_2In_1Out>().run_host_kernel(
        std::declval<const Tensor3D<typename Tensor3D_kernel_2In_1Out::Number>&>(),
        std::declval<const Tensor3D<typename Tensor3D_kernel_2In_1Out::Number>&>()
    )), Tensor3D<typename Tensor3D_kernel_2In_1Out::Number>>);

    static_assert(TENSOR3D_KERNEL_2IN_1OUT<Tensor3D_kernel_2In_1Out>, "not a valid TENSOR3D_KERNEL_2IN_1OUT");

    constexpr static bool check_passed = true;
};

template <template <HIP_scalar HIP_Number> class Tensor3D_kernel_2In_1Out>
struct Check_tensor3d_kernel_2In_1Out_template {
    static_assert(Check_tensor3d_kernel_2In_1Out<Tensor3D_kernel_2In_1Out<__half>>::check_passed);
    static_assert(Check_tensor3d_kernel_2In_1Out<Tensor3D_kernel_2In_1Out<float>>::check_passed);
    static_assert(Check_tensor3d_kernel_2In_1Out<Tensor3D_kernel_2In_1Out<double>>::check_passed);

    constexpr static bool check_passed = true;
};
