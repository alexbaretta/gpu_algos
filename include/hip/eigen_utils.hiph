/*
    Copyright (c) 2025 Alessandro Baretta <alex@baretta.com>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.
*/


// source path: include/hip/eigen_utils.hiph

#pragma once

#include <cmath>
#include <concepts>
#include <type_traits>
#include "type_traits.hiph"

struct Compute_error_absolute {
    template <std::floating_point Scalar>
    Scalar operator()(const Scalar& lhs, const Scalar& rhs) const {
        if (std::isnan(lhs) && std::isnan(rhs)) {
            // Both are NaN, so there is no error
            return 0;
        } else if (std::isinf(lhs) && std::isinf(rhs)) {
            const auto inf_delta = lhs - rhs;
            if (std::isnan(inf_delta)) {
                // lhs and rhs are both infinities, so inf_delta is NaN only if they are
                // infinities of the same sign, hence once could argue that there is no error
                return 0;
            }
            else { return std::abs<Scalar>(inf_delta); }
        } else {
            // lhs and rhs and normal numbers. We just compute the absolute difference.
            return std::abs<Scalar>(lhs - rhs);
        }
    }
    __half operator()(const __half& lhs, const __half& rhs) const {
        if (__hisnan(lhs) && __hisnan(rhs)) {
            // Both are NaN, so there is no error
            return 0;
        } else if (__hisinf(lhs) && __hisinf(rhs)) {
            const auto inf_delta = lhs - rhs;
            if (__hisnan(inf_delta)) {
                // lhs and rhs are both infinities, so inf_delta is NaN only if they are
                // infinities of the same sign, hence once could argue that there is no error
                return 0;
            }
            else { return __habs(inf_delta); }
        } else {
            // lhs and rhs and normal numbers. We just compute the difference.
            return __habs(lhs - rhs);
        }
    }
    template <HIP_integer Scalar>
    std::int64_t operator() (const Scalar& lhs, const Scalar& rhs) const {
        // There is no std::abs for unsigned integers, for obvious reasons, and subtraction
        // of signed integer types is subject to overflow. To make it easy for ourselves,
        // we use the widest signed integer type: int64_t
        return std::abs(std::int64_t(lhs) - std::int64_t(rhs));
    }
};

constexpr static Compute_error_absolute compute_error_absolute{};

struct Compute_error_relative {
    template <HIP_scalar Scalar>
    double operator()(const Scalar& lhs, const Scalar& rhs) const {
        const auto e = compute_error_absolute(lhs, rhs);
        if (e == decltype(e){0}) {
            return 0;
        } else {
            return double(e)/std::abs(double(rhs));
        }
    }
};

constexpr static Compute_error_relative compute_error_relative{};
