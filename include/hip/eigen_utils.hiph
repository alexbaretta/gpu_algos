// Copyright (c) 2025 Alessandro Baretta
// All rights reserved.

// source path: include/hip/eigen_utils.hiph

#pragma once

#include <Eigen/Core>

#include "type_traits.hiph"

struct ComputeError {
    template <std::floating_point Scalar>
    Scalar operator()(const Scalar lhs, const Scalar rhs) const {
        if (std::isnan(lhs) && std::isnan(rhs)) {
            // Both are NaN, so there is no error
            return 0;
        } else if (std::isinf(lhs) && std::isinf(rhs)) {
            const auto inf_delta = lhs - rhs;
            if (std::isnan(inf_delta)) {
                // lhs and rhs are both infinities, so inf_delta is NaN only if they are
                // infinities of the same sign, hence there is no error
                return 0;
            }
            else { return inf_delta; }
        } else {
            // lhs and rhs and normal numbers. We just compute the difference.
            return lhs - rhs;
        }
    }
    __half operator()(const __half lhs, const __half rhs) const {
        if (__hisnan(lhs) && __hisnan(rhs)) {
            // Both are NaN, so there is no error
            return 0;
        } else if (__hisinf(lhs) && __hisinf(rhs)) {
            const auto inf_delta = lhs - rhs;
            if (__hisnan(inf_delta)) {
                // lhs and rhs are both infinities, so inf_delta is NaN only if they are
                // infinities of the same sign, hence there is no error
                return 0;
            }
            else { return inf_delta; }
        } else {
            // lhs and rhs and normal numbers. We just compute the difference.
            return lhs - rhs;
        }
    }
    template <HIP_integer Scalar>
    Scalar operator() (const Scalar lhs, const Scalar rhs) const {
        // For integers, we do nothing special.
        return lhs - rhs;
    }
};

constexpr static ComputeError compute_error{};
